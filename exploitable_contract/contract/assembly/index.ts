import {storage, context, env, u128, ContractPromise, ContractPromiseBatch,
        ContractPromiseResult, logging, math, PersistentVector} from "near-sdk-as";
import {user_to_idx, idx_to_user, user_balance, User} from "./model"


// Aux functions --------------------------------------------------------------
// ----------------------------------------------------------------------------
function check_internal():void{
  // Check that callback functions are called by this contract
  assert(context.predecessor == context.contractName, "Just don't")
}


function get_callback_result():ContractPromiseResult{
  // Return the result from the external pool
  let results = ContractPromise.getResults()

  if(results.length > 0){ return results[0] }
  
  // Function is being called directly by our contract => TESTING
  return new ContractPromiseResult(1)
}


// Get user info --------------------------------------------------------------
// ----------------------------------------------------------------------------
export function get_user(user:string): User{
  if(!user_to_idx.contains(user)){
    return new User(user, u128.Zero)
  }

  const idx:i32 = user_to_idx.getSome(user)
  const balance:u128 = user_balance[idx]

  return new User(user, balance)
}


export function get_all_users(): Array<User>{
  let res:Array<User> = new Array<User>()
  for(let i:i32=0; i < user_balance.length; i++){
    let name:string = idx_to_user.getSome(i)
    let balance:u128 = user_balance[i]
    res.push(new User(name, balance))
  }
  return res
}

// Deposit --------------------------------------------------------------------
// ----------------------------------------------------------------------------
export function deposit():bool{
  const user:string = context.predecessor
  let idx:i32

  if(user_to_idx.contains(user)){
    logging.log("Deposit on user: " + idx.toString())
    idx = user_to_idx.getSome(user)
  }else{
    idx = storage.getPrimitive<i32>('total_users', 0)
    storage.set<i32>('total_users', idx+1)
    
    logging.log("Creating user: " + idx.toString())
    user_to_idx.set(user, idx)
    user_balance.push(u128.Zero)
    idx_to_user.set(idx, user)
  }
  
  user_balance[idx] = user_balance[idx] + context.attachedDeposit

  return true
}


// Withdraw - ! ---------------------------------------------------------------
// This function can be exploited to take more money --------------------------
@nearBindgen
class IntArgs{
  constructor(public idx:i32, public amount:u128){}
}

export function withdraw_reentrance(amount:u128):void{
  assert(user_to_idx.contains(context.predecessor), "User dont exist")
  
  let idx:i32 = user_to_idx.getSome(context.predecessor)

  assert(amount <= user_balance[idx], "Not enough money")

  // Send money to the user and callback
  let iargs:IntArgs = new IntArgs(idx, amount)
  
  ContractPromiseBatch.create(context.predecessor)
  .transfer(amount)
  .then(context.contractName)
  .function_call("_withdraw_reentrance", iargs.encode(),
                 u128.Zero, 7000000000000)
}

export function _withdraw_reentrance(idx:i32, amount:u128):void{
  check_internal()

  let response = get_callback_result()

  if(response.status == 1){
    user_balance[idx] = user_balance[idx] - amount
  }
}


// Withdraw -------------------------------------------------------------------
// This function can NOT be exploited -----------------------------------------
export function withdraw(amount:u128):void{
  assert(user_to_idx.contains(context.predecessor), "User dont exist")
  
  let idx:i32 = user_to_idx.getSome(context.predecessor)

  assert(amount <= user_balance[idx], "Not enough money")
  
  // Reduce the user balance before the external call 
  user_balance[idx] = user_balance[idx] - amount

  // Send money to the user and callback
  let iargs:IntArgs = new IntArgs(idx, amount)
  
  ContractPromiseBatch.create(context.predecessor)
  .transfer(amount)
  .then(context.contractName)
  .function_call("_withdraw", iargs.encode(),
                 u128.Zero, 7000000000000)
}

export function _withdraw(idx:i32, amount:u128):void{
  check_internal()

  let response = get_callback_result()

  if(response.status != 1){
    // Rollback
    user_balance[idx] = user_balance[idx] + amount
  }
}
